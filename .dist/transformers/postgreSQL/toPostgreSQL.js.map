{"version":3,"names":[],"mappings":"","sources":["transformers/postgreSQL/toPostgreSQL.js"],"sourcesContent":["import _ from 'lodash';\n\nimport {createSchema, createTable, createType} from './sql';\n\nexport default function toPostgreSQL({model, orderedTables}) {\n  const {commonAttributes: modelAttributes, schemas} = model;\n\n  const schemaMap = _.transform(schemas, (map, schema) => map[schema.name] = addTableMap(schema), {});\n\n  model.schemaMap = schemaMap; // mutation of passed object!\n\n  resolveDependencies(schemas, schemaMap);\n\n  return createSchemas(schemas, schemaMap, orderedTables);\n\n  function addTableMap(schema) {\n    schema.tableMap = _.transform(schema.tables, (map, table) => map[table.name] = table, {});\n    return schema;\n  }\n\n  // This should be broken out into a separate model, but we want the schema map and that is here!\n  function resolveDependencies(schemas, schemaMap) {\n    schemas.forEach(({tables}) => tables.forEach(table => table.primaryKeys = _.filter(table.attributes, a => a.primaryKey)));\n    schemas.forEach(({name, tables}) => {\n      return tables.forEach(table => {\n        const {name: tableName, dependencies} = table;\n        return dependencies.forEach(({reference}) => {\n          reference.attribute = schemaMap[reference.schema || name].tableMap[reference.table].primaryKeys[0];\n        });\n      });\n    });\n  }\n\n  function createSchemas(schemas, schemaMap, orderedTables) {\n    return _.concat(\n      _.map(_.keys(schemaMap), createSchema), // Produce all schemas first\n      _.flatMap(orderedTables, processTable)\n    );\n  }\n\n  function processTable(qualifiedTableName) {\n    const [schemaName, tableName] = qualifiedTableName.split('.');\n\n    const commands = [];\n\n    const schema = schemaMap[schemaName],\n          {commonAttributes: schemaAttributes} = schema,\n          table = schema.tableMap[tableName],\n          attributes = _.flatMap([modelAttributes, schemaAttributes, table.attributes]),\n          primaryKeys = table.primaryKeys,\n          columns = _.map(attributes, generateAttribute)\n                     .concat(_.map(table.dependencies, generateDependency))\n                     .join(', ');\n\n    const constraints = [];\n\n    if (primaryKeys.length > 0) constraints.push(`PRIMARY KEY (${primaryKeys.map(a => a.name)})`);\n\n    commands.push(createTable(`${schemaName}.${tableName}`, columns, constraints));\n\n    return commands;\n\n    function generateAttribute({name, primaryKey, optional, type}) {\n      const parts = [name, type ? formatType(type) : 'text'];\n\n      if (primaryKey && optional) throw new Error(`${schemaName}.${tableName}.${name} cannot be both a primary key and optional!`); // maybe outlaw this in the grammar?\n\n      if (!primaryKey && !optional) parts.push('NOT NULL');\n\n      return parts.join(' ');\n\n      function formatType(type) {\n        if (typeof type === 'string') {\n          if (type === 'timestamp') return `${type} DEFAULT now()`;\n          return type;\n        }\n\n        if (type.type === 'Set') {\n          // These names are guaranteed to be unique, but maybe we want a way to de-duplicate equivalent types?\n          const newTypeName = `${tableName}_${name}_enum`;\n          commands.push(createType(`${schemaName}.${newTypeName}`, type.values));\n\n          return `${newTypeName} DEFAULT '${type.values[0]}'`;\n        }\n        else if (type.type === 'Numeric') {\n          const parameters = [];\n          if (type.precision !== undefined) parameters.push(type.precision);\n          if (type.scale !== undefined) parameters.push(type.scale);\n\n          if (parameters.length > 0) return `NUMERIC(${parameters.join(',')})`;\n          return `NUMERIC`;\n        }\n        else if (type.type === 'Blob') {\n          return `BYTEA`;\n        }\n        else if (type.type === 'VarChar') {\n          if (type.length !== undefined) return `VARCHAR(${type.length})`;\n          return `VARCHAR`;\n        }\n        else throw new Error(`${type.type} not implemented!`);\n      }\n    }\n\n    function generateDependency({preArity, postArity, reference: {schema, table, attribute}}) {\n      const id = (schema === undefined ? '' : `${schema || schemaName}_`) + `${table}_${(attribute || {name: 'id'}).name}`,\n            references = `${schema || schemaName}.${table}`;\n\n      let type = (attribute || {type: 'bigint'}).type;\n\n      if (typeof type !== 'string') type = type.type;\n      type = `${type} NOT NULL`;\n\n      if (preArity === 1 && postArity === 1) type += ' UNIQUE';\n\n      return `${id} ${type} REFERENCES ${references}`;\n    }\n  }\n}\n\nexport function resolveDependencies({schemas}) {\n  schemas.forEach(({tables}) => {\n\n  });\n}\n\n\n// get primaryKeys() { return _.filter(attributes, a => a.primaryKey); }"],"file":"transformers/postgreSQL/toPostgreSQL.js","sourceRoot":"/source/"}