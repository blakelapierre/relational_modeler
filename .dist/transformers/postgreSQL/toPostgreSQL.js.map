{"version":3,"names":[],"mappings":"","sources":["transformers/postgreSQL/toPostgreSQL.js"],"sourcesContent":["import _ from 'lodash';\n\nimport {createSchema, createTable, createType} from './sql';\n\nexport default function toPostgreSQL({model, orderedTables}) {\n  const {commonAttributes: modelAttributes, schemas} = model;\n\n  const schemaMap = _.transform(schemas, (map, schema) => map[schema.name] = addTableMap(schema), {});\n\n  model.schemaMap = schemaMap; // mutation of passed object!\n\n  return createSchemas(schemas, schemaMap, orderedTables);\n\n  function addTableMap(schema) {\n    schema.tableMap = _.transform(schema.tables, (map, table) => map[table.name] = table, {});\n    return schema;\n  }\n\n  function createSchemas(schemas, schemaMap, orderedTables) {\n    return _.concat(\n      _.map(_.keys(schemaMap), createSchema), // Produce all schemas first\n      _.flatMap(orderedTables, processTable)\n    );\n  }\n\n  function processTable(qualifiedTableName) {\n    const [schemaName, tableName] = qualifiedTableName.split('.');\n\n    const commands = [];\n\n    const schema = schemaMap[schemaName],\n          {commonAttributes: schemaAttributes} = schema,\n          table = schema.tableMap[tableName],\n          attributes = _.flatMap([modelAttributes, schemaAttributes, table.attributes]),\n          columns = _.map(attributes, generateAttribute)\n                     .concat(_.map(table.dependencies, generateDependency))\n                     .join(', ');\n\n    commands.push(createTable(`${schemaName}.${tableName}`, columns));\n\n    return commands;\n\n    function generateAttribute({name, primaryKey, optional, type}) {\n      const parts = [name, type ? formatType(type) : 'text'];\n\n      if (primaryKey && optional) throw new Error(`${schemaName}.${tableName}.${name} cannot be both a primary key and optional!`); // maybe outlaw this in the grammar?\n      if (primaryKey) parts.push('PRIMARY KEY');\n      else if (!optional) parts.push('NOT NULL');\n\n      return parts.join(' ');\n\n      function formatType(type) {\n        if (typeof type === 'string') {\n          if (type === 'timestamp') return `${type} DEFAULT now()`;\n          return type;\n        }\n\n        if (type.type === 'Set') {\n          // These names are guaranteed to be unique, but maybe we want a way to de-duplicate equivalent types?\n          const newTypeName = `${tableName}_${name}_enum`;\n          commands.push(createType(`${schemaName}.${newTypeName}`, type.values));\n\n          return `${newTypeName} DEFAULT '${type.values[0]}'`;\n        }\n        else if (type.type === 'Numeric') {\n          const parameters = [];\n          if (type.precision !== undefined) parameters.push(type.precision);\n          if (type.scale !== undefined) parameters.push(type.scale);\n\n          if (parameters.length > 0) return `NUMERIC(${parameters.join(',')})`;\n          return `NUMERIC`;\n        }\n        else if (type.type === 'Blob') {\n          return `BYTEA`;\n        }\n        else throw new Error(`${type.type} not implemented!`);\n      }\n    }\n\n    function generateDependency({preArity, postArity, reference: {schema, table}}) {\n      const id = (schema === undefined ? '' : `${schema || schemaName}_`) + `${table}_id`,\n            references = `${schema || schemaName}.${table}`;\n\n      let type = 'bigint NOT NULL';\n\n      if (postArity === 1) type += ' UNIQUE';\n\n      return `${id} ${type} REFERENCES ${references}`;\n    }\n  }\n}"],"file":"transformers/postgreSQL/toPostgreSQL.js","sourceRoot":"/source/"}