{"version":3,"names":[],"mappings":"","sources":["grammar/RM.toObject.semantics.js"],"sourcesContent":["const defaultType = 'text',\n      defaultPrimaryKeyType = 'bigserial';\n\nexport default {\n  ListOf_some (element, separator, rest) {\n    return [element.toObject()].concat(rest.toObject());\n  },\n\n  IContained (open, element, close) {\n    return element.toObject();\n  },\n\n  Model (name, commonAttributes, schemas) {\n    return join({name, commonAttributes: commonAttributes.toObject()[0] || [], schemas});\n  },\n\n  Schema (name, commonAttributes, tables) {\n    return join({name, commonAttributes: commonAttributes.toObject()[0] || [], tables});\n  },\n\n  Table (name, attributes, dependencies) {\n    return join({name, attributes: attributes.toObject()[0], dependencies});\n  },\n\n  Attribute (primaryKey, name, optional, type) {\n    primaryKey = primaryKey.toObject()[0] === '!';\n    type = type.toObject()[0] || (primaryKey ? defaultPrimaryKeyType : defaultType);\n    return join({name, primaryKey, optional: optional.toObject()[0] === '?', type});\n  },\n\n  Type (type) {\n    return type.toObject();\n  },\n\n  List (values) {\n    return join({type: 'List', values});\n  },\n\n  Set (values) {\n    return join({type: 'Set', values});\n  },\n\n  Dependency (preArity, glyph, postArity, reference) {\n    return join({\n      preArity: $ => $(preArity)[0] || 1,\n      postArity: $ => $(postArity)[0] || 1,\n      reference\n    });\n  },\n\n  SchemaTableName (schema, dot, table) {\n    return join({schema, table});\n  },\n\n  TableName (table) {\n    return join({table});\n  },\n\n  name (first_character, additional_characters) {\n    return this.interval.contents;\n  }\n};\n\nfunction join(obj) {\n  for (let key in obj) {\n    if (typeof obj[key] === 'function') obj[key] = obj[key](o => o.toObject());\n    else if (obj[key].toObject) obj[key] = obj[key].toObject();\n  }\n  return obj;\n}"],"file":"grammar/RM.toObject.semantics.js","sourceRoot":"/source/"}